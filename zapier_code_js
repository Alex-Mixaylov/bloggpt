const title   = inputData.title || "";
const meta    = inputData.meta || "";
const content = inputData.content || "";
const hasText = typeof inputData.text === "string" && inputData.text.length > 0;

// экранирование MarkdownV2 c сохранением URL
function escapeMdV2(str) {
  let s = (str || "").toString();

  // 1) временно выносим ссылки
  const urls = [];
  s = s.replace(/https?:\/\/[^\s)]+/g, (m) => {
    urls.push(m);
    return `__URL_${urls.length - 1}__`;
  });

  // 2) экранируем обратный слэш и спецсимволы
  // (без lookbehind — совместимо в Zapier)
  s = s.replace(/\\/g, "\\\\");
  s = s.replace(/([_*\[\]()~`>#+\-=|{}.!])/g, "\\$1");

  // 3) возвращаем ссылки
  s = s.replace(/__URL_(\d+)__/g, (_, i) => urls[+i]);
  return s;
}

// конвертация строк вида "## Заголовок" -> "*Заголовок*" + экранирование
function convertHeadingsAndEscape(text) {
  const lines = (text || "").split(/\r?\n/);
  const out = lines.map(line => {
    const m = line.match(/^\s*#{1,6}\s+(.*)$/);
    if (m) {
      const payload = m[1];
      const esc = escapeMdV2(payload);
      // ВАЖНО: звёздочки добавляем ПОСЛЕ экранирования, чтобы они остались разметкой
      return `*${esc}*`;
    } else {
      return escapeMdV2(line);
    }
  });
  return out.join("\n");
}

let text;

if (hasText) {
  // Единая строка: конвертируем заголовки и экранируем остальное
  text = convertHeadingsAndEscape(inputData.text);
} else {
  // Раздельные поля: экранируем каждое поле, title делаем жирным
  const escTitle   = escapeMdV2(title);
  const escMeta    = escapeMdV2(meta);
  const escContent = convertHeadingsAndEscape(content); // вдруг там есть ##

  const parts = [];
  if (escTitle)   parts.push(`*${escTitle}*`); // звёздочки после экранирования!
  if (escMeta)    parts.push(escMeta);
  if (escContent) parts.push(escContent);

  text = parts.join("\n\n");
}

return {
  text,
  text_preview: text.slice(0, 250),
  had_single_text_input: hasText
};
